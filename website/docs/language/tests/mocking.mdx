---
page_title: Tests - Provider Mocking
description: >-
  Provide mocked data for providers and resources within `terraform test`.
---

# Mocks

-> **Note:** Mocked providers and the associated syntax are available in Terraform v1.7.0 and later.

Prior to Terraform v1.7.0, Terraform test authors were required to initialize and configure real Terraform providers for their tests. The `command = plan` setting could be used to avoid creating real infrastructure, but providers were still required to be correctly configured with the appropriate credentials and cloud accounts.

In Terraform v1.7.0, we launched support for mocking providers and modules, along with resources and data sources, within the Terraform test framework. Test authors can now use mock (or fake) providers, and their associated resources within their tests, requiring no credentials or associated accounts to exist. Within the context of `terraform test`, a mocked provider or resource will generate fake data for all computed attributes that would normally be provided by the underlying provider APIs.

Mocking functionality can only be used within the context of the [`terraform test` language](/terraform/language/tests). Readers of the mocking documentation should be aware of the surrounding testing syntax and language features.

In addition, the more advanced features of the mocking framework require knowledge about the following Terraform provider features:

- The difference between [attributes, nested attributes,](/terraform/plugin/framework/handling-data/attributes) and [blocks](https://developer.hashicorp.com/terraform/plugin/framework/handling-data/blocks).
- Definitions of [optional, required, and computed attributes](/terraform/plugin/framework/handling-data/attributes/string#configurability).


## Mock Providers

Within Terraform test files, you can use a new block type: `mock_provider`.

Mock providers return the same schema as the original provider and can be passed into your configuration under test in place of the matching provider. All resources and data sources retrieved by a mock provider will set the relevant values from the configuration, and generate fake data for any computed attributes.

Mock providers can be used directly in place of traditional `provider` blocks, and they share the same global namespace. During the execution of the `terraform test` command, Terraform does not distinguish between a real and a mocked provider.

The following example demonstrates a configuration that creates an AWS S3 bucket, and then uses a mocked provider in order to test the configuration without requiring an AWS account.

```hcl
# main.tf

terraform {
  required_providers {
    aws = {
        source = "hashicorp/aws"
    }
  }
}

variable "bucket_name" {
    type = string
}

resource "aws_s3_bucket" "my_bucket" {
    bucket = var.bucket_name
}
```

```hcl
# bucket_name.tftest.hcl

mock_provider "aws" {}

run "sets_correct_name" {
  variables {
    bucket_name = "my_bucket_name"
  }

  assert {
    condition     = aws_s3_bucket.my_bucket.bucket == "my_bucket_name"
    error_message = "incorrect bucket name"
  }
}
```

The above example validates the configuration is setting the correct bucket name on the AWS S3 bucket, and we can execute the test without provisioning an AWS account and accessing credentials first.

From the perspective of any `plan` or `apply` operations executed within a Terraform test file, the mocked provider is creating actual resources with values that match the configuration. These resources are stored within the Terraform state files that `terraform test` creates and holds in memory during test executions.

We can also interleave mocked providers and real providers within a Terraform test. In the following example we define two AWS providers, one real and one mocked. We must provide an alias to one of them, as they share the same global `aws` provider namespace. We can then use the `providers` attribute within test run blocks to customize which AWS provider is used for each run block. This behavior is the same as if we had defined two real providers, or two mocked providers, highlighting that Terraform considers mocked providers and real providers to be providers for the same set of resources.

```hcl
# mocked_providers.tftest.hcl

provider "aws" {}

mock_provider "aws" {
  alias = fake
}

run "use_real_provider" {
  providers = {
    aws = aws
  }
}

run "use_mocked_provider" {
  providers = {
    aws = aws.fake
  }
}
```

### Generated data

A mocked provider will generate data for any computed attributes within referenced data sources or attributes. For example, the `arn` attribute is a unique identifier generated by AWS for most resources. A mocked `aws` provider will provide a value for this attribute in any resources it creates.

> **Note**: Mocked providers do not have any information about the expected format of the computed attributes, so the generated data will rarely match any expected syntax that real providers would return for those attributes.

The generated data depends on the type of the underlying attributes:

- Numbers will be 0.
- Booleans will be false.
- Strings will be a random 8 character alphanumeric string.
- Collections, including sets, lists, and maps, will be empty collections.
- Objects will contain all required sub-attributes generated using this same set of rules recursively.

The above rules are consistent regardless of the type of the mocked provider, so a mocked `aws` and a mocked `google` provider apply the same rules when generating data.

Mocked providers only generate data for **computed** attributes, any attributes that are expected to be set in the configuration for a real provider must also be set for a mocked provider. Any optional and computed attributes will only be generated if the configuration does not already contain a value for them. An example of this is the `bucket` attribute in the `aws_s3_bucket` resource. A real AWS provider will generate a bucket name if one is not specified. A mocked AWS provider will do the same, and only generate a value if one is not already specified within the configuration.

### Mock Provider data

The automatically generated data, while useful for general consumption of mocked providers, may not match data required for a specific test. You can specify specific values you want to return for targeted resources and data sources.

Within a `mock_provider` block, you can write any number of `mock_resource` and `mock_data` blocks. Both accept a type argument that should match the resource or data source you want to provide values for. Both nested blocks accept a `defaults` object attribute, in which you can specify the values that should be returned for specific attributes.

The following example demonstrates providing a set `arn` value for all AWS S3 bucket resources and data sources:

```hcl
mock_provider "aws" {
  mock_resource "aws_s3_bucket" {
    defaults = {
      arn = "arn:aws:s3:::name"
    }
  }

  mock_data "aws_s3_bucket" {
    defaults = {
      arn = "arn:aws:s3:::name"
    }
  }
}
```

Now, Terraform will use the supplied value for `arn` attributes within S3 buckets instead of following the generated data rules and creating a random 8 character alphanumeric string. Computed attributes not provided an explicit default will simply fall back to the generic data generation rules.

You can also share mock provider data between tests by writing dedicated mock data files, and using the `source` attribute within the `mock_provider` block. Mock data files have `.tfmock.hcl` or `.tfmock.json` extensions, and can contain `mock_resource` and `mock_data` blocks as if they were defined within the `mock_provider` block directly.

```hcl
# ./testing/aws/data.tfmock.hcl
mock_resource "aws_s3_bucket" {
  defaults = {
    arn = "arn:aws:s3:::name"
  }
}

mock_data "aws_s3_bucket" {
  defaults = {
    arn = "arn:aws:s3:::name"
  }
}
```

```hcl
mock_provider "aws" {
  source = "./testing/aws"
}
```

In the above example, we've defined our `mock_resource` and `mock_data` blocks within a mock data file within the relative directory `./testing/aws`. We can then have multiple test files load the same mock provider data without copying the same definitions across all files.

You can combine the `source` attribute with directly nested `mock_resource` and `mock_data` blocks. If the source location and a directly nested block describe the same resource or data source then the directly nested block takes precedence.

## Overrides

In addition to mocking entire providers, you can override specific resources, data sources, and modules.

Terraform v1.7.0 introduced three new block types within Terraform test files:

- `override_resource`: Override the values of a specific resource. The underlying provider will not be consulted for the overridden resource.
- `override_data`: Override the values of a specific data source. The underlying provider will not be consulted for the overridden data source.
- `override_module`: Override the outputs of a specific module call. Any resources within the module will not be created, and the specified outputs will be returned instead.

The `override_module` block can be placed at the root level of Terraform test files and within Terraform test file run blocks.

The `override_resource` and `override_data` blocks can also be placed at the root level of Terraform test files and within Terraform test file run blocks. In addition, they can be nested within `mock_provider` blocks and within Terraform mock data files.

Overrides can be used alongside both real and mocked providers. In both cases, the override provides the computed values instead of the underlying provider.

### Overrides Syntax

All override blocks contain a `target` attribute, which should specify the resource, data source, or module that should be overridden. The `override_module` blocks then contain an `outputs` attribute, while the `override_resource` and `override_data` blocks contain a `values` attribute.

As with the `defaults` attribute in the `mock_resource` and `mock_data` blocks, the `outputs` and `values` attributes are optional and any outputs or computed attributes not specified will be generated by the testing framework.

The following example demonstrates using the override blocks at various different scopes and levels. We have a module that reads a file from an S3 bucket, and then we create a local file that contains the data read from S3.

```hcl
# main.tf

terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
    }
  }
}

module "credentials" {
  source = "./modules/credentials"

  data_bucket_name = "my_company_bucket_name"
}

resource "local_file" "credentials_json" {
  filename = "credentials.json"
  content = jsonencode(module.credentials.data)
}


```

```hcl
# ./modules/s3_data/main.tf

variable "data_bucket_name" {
  type = string
}

data "aws_s3_bucket_object" "data_bucket" {
  bucket = var.data_bucket_name
  key = "credentials.json"
}

output "data" {
  value = jsondecode(data.aws_s3_bucket_object.data_bucket.body)
}
```

Firstly, we could override the `aws_s3_bucket_object` directly within our mock provider. We implement the `override_data` block within the `mock_provider` block, this means that the target data source will only be overridden if it is loaded by that specific mock provider.

```hcl
# main.tftest.hcl

mock_provider "aws" {
  override_data {
    target = module.credentials.data.aws_s3_bucket_object.data_bucket
    values = {
      data = "{\"username\":\"username\",\"password\":\"password\"}"
    }
  }
}

run "test" {
  assert {
    condition     = jsondecode(local_file.credentials_json.content).username == "username"
    error_message = "incorrect username"
  }
}
```

Alternatively, we could override the `aws_s3_bucket_object` within the test file itself, or within our run block. In this case, the underlying provider doesn't matter as we'll override the data source at the target address regardless of the provider. Overrides can override resources that provided by real providers.

```hcl
# main.tftest.hcl

override_data {
  target = module.credentials.data.aws_s3_bucket_object.data_bucket
  values = {
    body = "{\"username\":\"username\",\"password\":\"password\"}"
  }
}

run "test_file_override" {
  assert {
    condition     = jsondecode(local_file.credentials_json.content).username == "username"
    error_message = "incorrect username"
  }
}

run "test_run_override" {
  # We provide a different override locally within this run block, in which case
  # our local override takes precedence over the alternate defined within the
  # file.
  override_data {
    target = module.credentials.data.aws_s3_bucket_object.data_bucket
    values = {
      body = "{\"username\":\"a_different_username\",\"password\":\"password\"}"
    }
  }

  assert {
    condition     = jsondecode(local_file.credentials_json.content).username == "a_different_username"
    error_message = "incorrect username"
  }
}
```

In the above example, we create a file override that our first run block uses. We then create an alternative local override within the second run block that takes precedence over the file level override. File level overrides and run block overrides both take precedence over overrides defined within mock providers.

Finally, we can override the entire module instead of worrying about the internal implementation of the module:

```hcl
# main.tftest.hcl

override_module {
  target = module.credentials
  outputs = {
    data = { username = "username", password = "password" }
  }
}

run "test" {
  assert {
    condition     = jsondecode(local_file.credentials_json.content).username == "username"
    error_message = "incorrect username"
  }
}
```

In the above example, we have overridden the module entirely instead of the specific resources within the module. In this case, we've tweaked the override block to reflect we are specifying `outputs` and we specify the output as HCL instead of as a string and we are expecting the output to have been precessed through the `jsonencode` function. As with `override_data` blocks, we could specify the `override_module` block within the run block as well and the same precedence rules apply.

The `override_resource` blocks match the behaviour of the `override_data` blocks.

## Generating values for repeated blocks

The examples within this page have so far focused on generating values for attributes. Some resources and data sources specify nested attributes and blocks as computed.

For repeated blocks and nested attributes, you cannot specify values for specific instances within the collection. Instead, you provide a single set of values that apply for all instances within the collection.

As an example, consider the `aws_dynamodb_table` resource. It contains a root level computed `arn` attribute, and a set-repeated block called `replica` which also contains a computed `arn` attribute. A typical configuration might look like this:

```hcl
# main.tf

resource "aws_dynamodb_table" "my_table" {
  name     = "my_table"
  hash_key = "key"

  attribute {
    name = "key"
    type = "S"
  }

  replica {
    region_name = "eu-west-2"
  }

  replica {
    region_name = "us-east-1"
  }
}
```

In normal execution, we'd expect the AWS provider to return ARN values for the main DynamoDB table and for both the specified replicas. We can create a `mock_resource` that mimics this behavior, but we cannot differentiate between the multiple `replica` blocks within the resource:

```hcl
mock_resource "aws_dynamodb_table" {
  defaults = {
    arn     = "aws:dynamodb:::my_table"
    replica = {
      arn = "aws:dynamodb:::my_replica"
    }
  }
}
```

In this case we have specified a value for ARN returned for the main table, but we have to share the ARN value returned for the replica tables by specifying a single object that will be used for all instances within the configuration. It is not currently possible to specify values for specific instances within nested block types during `terraform test` executions.

The reason for this behaviour is that it is not possible for Terraform to match repeated blocks in a set between the configuration and the specified values from the mock or override block. Terraform has no way to resolve which instance within the values should apply to which instance within the configuration, so we simply state that you provide a single set of values for all instances within the configuration.
